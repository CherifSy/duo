#!/usr/bin/env node

/**
 * Module dependencies.
 */

var write = require('fs').createWriteStream;
var Command = require('commander').Command;
var resolve = require('path').resolve;
var exists = require('fs').existsSync;
var type = require('component-type');
var mkdirp = require('mkdirp').sync;
var Logger = require('stream-log');
var stat = require('fs').statSync;
var spawn = require('win-fork');
var pkg = require('../package');
var Batch = require('batch');
var path = require('path');
var dirname = path.dirname;
var fs = require('co-fs');
var cwd = process.cwd();
var Duo = require('..');
var join = path.join;

/**
 * Logger
 */

var logger = new Logger(process.stderr)
  .type('building', '36m')
  .type('built', '36m')
  .type('installing', '36m')
  .type('installed', '36m')
  .type('finding', '36m')
  .type('found', '36m');

/**
 * Error
 */

logger.type('error', '31m', function(){
  logger.end();
  process.exit(1);
});

/**
 * Program
 */

var program = new Command('duo')
  .version(pkg.version)
  .usage('<command> [options]')
  .option('-d, --development', 'include development dependencies.', false)
  .option('-r, --root <dir>', 'root directory to build from.', null)
  .option('-g, --global <name>', 'expose entry as a global <name>', null)
  .option('-v, --verbose', 'show as much logs as possible', false)
  .option('-c, --concurrency <n>', 'set concurrency, defaulted to 50', 50)
  .parse(process.argv);

/**
 * Help
 */

program.on('--help', function(){
  console.log('  Usage:');
  console.log();
  console.log('  # build in.js and output out.js');
  console.log('  $ duo in.js > out.js');
  console.log('  $ duo in.js out.js');
  console.log();
  console.log('  # build in.css and output out.css');
  console.log('  $ duo in.css > out.css');
  console.log('  $ duo in.css out.css');
  console.log();
  console.log('  Commands:');
  console.log();
  console.log('    ls           list all dependencies.');
  console.log('    duplicates   show all duplicates.');
  console.log();
  process.exit(0);
});

/**
 * Arguments
 */

var args = process.argv.slice(3);

/**
 * Command
 */

var command = program.args[0];

/**
 * PATH
 */

var paths = [__dirname].concat(process.env.PATH.split(':'));

/**
 * Bin
 */

var bin = ['duo', command].join('-');

/**
 * Custom executable
 */

if (command && !~command.indexOf('.')) {
  // find executable
  var exec = paths.reduce(function(binary, path){
    path = resolve(path, bin);
    return exists(path) && stat(path)
      ? path
      : binary;
  }, bin);

  // does not exist
  if (!exists(exec)) {
    logger.error(bin + '(1) does not exist');
    return;
  }

  // spawn
  args.unshift(exec);
  args.unshift('--harmony-generators');
  var proc = spawn('node', args, { stdio: 'inherit', customFds: [0, 1, 2] });
  proc.on('close', process.exit.bind(process));

  return;
}

/**
 * Build a single file
 */

if (command) {
  var root = base(program.root);
  var duo = create(root, command);
  var out = process.stdout;

  if (program.args[1]) {
    var file = path.join(root, program.args[1]);
    mkdirp(path.dirname(file));
    out = write(file);
  }

  duo.run(function(err, str) {
    if (err) throw error(err);
    out.write(str);
  })

  return;
}

/**
 * Build multiple files
 */

var root = findroot(cwd);
var mains = entries(root);
var batch = Batch();
var srcs = {};

// add entries
mains.forEach(function(main) {
  var duo = create(root, main);
  logger.building(main);

  batch.push(function(fn) {
    duo.write(function(err) {
      if (err) return fn(err);
      logger.built(main);
      fn();
    });
  })
})

// run duo all the entries
batch.end(function(err) {
  if (err) throw error(err);
  logger.end();
});

/**
 * Create a duo instance
 *
 * @param {String} root
 * @param {entry} entry
 */

function create(root, entry) {
  var duo = Duo(root)
    .development(!! program.development)
    .concurrency(program.concurrency)
    .entry(entry);

  // global
  program.global && duo.global(program.global);

  // verbose
  if (program.verbose) {
    duo.on('resolving', log('finding'));
    duo.on('resolve', log('found'));
    duo.on('fetching', log('installing'));
  }

  // installed
  duo.on('fetch', log('installed'));

  return duo;
}

/**
 * Log an event
 *
 * @param {String} event
 * @return {Function}
 */

function log (event) {
  return function(pkg) {
    logger[event](pkg.slug());
  }
}

/**
 * Error
 */

function error(err) {
  logger.error(err.stack);
  logger.end();
}

/**
 * Get the entries
 */

function entries(root) {
  if (command) return [command];
  var manifest = require(join(root, 'component.json'));
  var main = manifest.main || [];
  var t = type(main);

  switch(t) {
    case 'array': return main;
    case 'string': return [main];
    case 'object': return Object.keys(main);
    default: throw error(new Error(t + ': unknown main type'));
  }
}

/**
 * Find the root
 *
 * @param {String} root
 * @param {String}
 */

function findroot(root) {
  while (!exists(join(root, 'component.json')) && '/' != root) {
    root = dirname(root);
  }

  if ('/' == root) {
    logger.error('no manifest found');
    process.exit(1);
  }

  return root;
}

/**
 * Resolve the root
 *
 * @param {String} path
 * @return {String}
 */

function base(path) {
  return path
    ? resolve(cwd, path)
    : cwd;
}

